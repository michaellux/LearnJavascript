<html>
  <head>
    <meta charset="UTF-8" />
    <title>Перемешайте массив</title>
  </head>
  <body>
    <script>
      function shuffle(array) {
		 let order = [];
		 let count = 0;
		 while(count < array.length) {
			let randomNumber = Math.floor(Math.random() * 10);
			if((randomNumber >= array.length) || (order.indexOf(randomNumber) != -1)) {
				continue;
			}
			else {
				order.push(randomNumber);
			}
			randomNumber = 0;

			count++;
		 }

		 console.log(order);
		 
		 console.log(array);
		 
		 let resultArray = array.map(function(item, index) {
			 console.log("item " + item);
			 console.log("index " + index);
			 console.log("array-order " + array[order[index]]);
			 
			 item = array[order[index]];

			 return item;
		 });
		 
		 console.log(resultArray);
		 
		 alert(resultArray);
		 return resultArray;
	  }
	  
	  let arr = [1, 2, 3];

	  shuffle(arr);
	  // arr = [3, 2, 1]
  
	  shuffle(arr);
	  // arr = [2, 1, 3]
  
	  shuffle(arr);
	  // arr = [3, 1, 2]
	  // ...
	  /* Решение
	  
	  Простым решением может быть:

	function shuffle(array) {
	array.sort(() => Math.random() - 0.5);
	}

	let arr = [1, 2, 3];
	shuffle(arr);
	alert(arr);
	Это, конечно, будет работать, потому что Math.random() - 0.5 отдаёт случайное число, которое может быть положительным или отрицательным, следовательно, функция сортировки меняет порядок элементов случайным образом.

	Но поскольку метод sort не предназначен для использования в таких случаях, не все возможные варианты имеют одинаковую вероятность.

	Например, рассмотрим код ниже. Он запускает shuffle 1000000 раз и считает вероятность появления для всех возможных вариантов arr:

	function shuffle(array) {
	array.sort(() => Math.random() - 0.5);
	}

	// подсчёт вероятности для всех возможных вариантов
	let count = {
	'123': 0,
	'132': 0,
	'213': 0,
	'231': 0,
	'321': 0,
	'312': 0
	};

	for (let i = 0; i < 1000000; i++) {
	let array = [1, 2, 3];
	shuffle(array);
	count[array.join('')]++;
	}

	// показать количество всех возможных вариантов
	for (let key in count) {
	alert(`${key}: ${count[key]}`);
	}
	Результат примера (зависят от движка JS):

	123: 250706
	132: 124425
	213: 249618
	231: 124880
	312: 125148
	321: 125223
	Теперь мы отчётливо видим допущенное отклонение: 123 и 213 появляются намного чаще, чем остальные варианты.

	Результаты этого кода могут варьироваться при запуске на разных движках JavaScript, но очевидно, что такой подход не надёжен.

	Так почему это не работает? Если говорить простыми словами, то sort это «чёрный ящик»: мы бросаем в него массив и функцию сравнения, ожидая получить отсортированный массив. Но из-за абсолютной хаотичности сравнений чёрный ящик сходит с ума, и как именно он сходит с ума, зависит от конкретной его реализации, которая различна в разных движках JavaScript.

	Есть и другие хорошие способы решить эту задачу. Например, есть отличный алгоритм под названием Тасование Фишера — Йетса. Суть заключается в том, чтобы проходить по массиву в обратном порядке и менять местами каждый элемент со случайным элементом, который находится перед ним.

	function shuffle(array) {
	for (let i = array.length - 1; i > 0; i--) {
		let j = Math.floor(Math.random() * (i + 1)); // случайный индекс от 0 до i

		// поменять элементы местами
		// мы используем для этого синтаксис "деструктурирующее присваивание"
		// подробнее о нём - в следующих главах
		// то же самое можно записать как:
		// let t = array[i]; array[i] = array[j]; array[j] = t
		[array[i], array[j]] = [array[j], array[i]];
	}
	}
	Давайте проверим эту реализацию на том же примере:

	function shuffle(array) {
	for (let i = array.length - 1; i > 0; i--) {
		let j = Math.floor(Math.random() * (i + 1));
		[array[i], array[j]] = [array[j], array[i]];
	}
	}

	// подсчёт вероятности для всех возможных вариантов
	let count = {
	'123': 0,
	'132': 0,
	'213': 0,
	'231': 0,
	'321': 0,
	'312': 0
	};

	for (let i = 0; i < 1000000; i++) {
	let array = [1, 2, 3];
	shuffle(array);
	count[array.join('')]++;
	}

	// показать количество всех возможных вариантов
	for (let key in count) {
	alert(`${key}: ${count[key]}`);
	}
	Пример вывода:

	123: 166693
	132: 166647
	213: 166628
	231: 167517
	312: 166199
	321: 166316
	Теперь всё в порядке: все варианты появляются с одинаковой вероятностью.

	Кроме того, если посмотреть с точки зрения производительности, то алгоритм «Тасование Фишера — Йетса» намного быстрее, так как в нём нет лишних затрат на сортировку.
       */
    </script>
  </body>
</html>
